---
import DocsLayout from "../../layouts/DocsLayout.astro";

const varsTable = [
  { syntax: "{{input.xxx}}", desc: "Trigger-time inputs from the user" },
  { syntax: "{{vars.xxx}}", desc: "Pipeline-level global variables" },
  {
    syntax: "{{steps.&lt;id&gt;.output}}",
    desc: "Full output from a previous step",
  },
  {
    syntax: "{{steps.&lt;id&gt;.output.field}}",
    desc: "JSON field access on step output",
  },
  { syntax: "{{env.xxx}}", desc: "User-defined encrypted secrets" },
  {
    syntax: "{{#if condition}}...{{/if}}",
    desc: "Conditional blocks (Handlebars-like)",
  },
];
---

<DocsLayout title="Pipeline Format" breadcrumb={[{ label: "Docs", href: "/docs" }, { label: "Pipeline Format" }]}>
  <h1>Pipeline Format</h1>
  <p>Pipelines are defined in YAML or JSON. Each pipeline has a name, optional variables, an input schema, a list of steps, and output delivery configuration.</p>

  <div class="docs-info-box">
    You can validate any pipeline definition without saving it using <code>POST /api/pipelines/validate</code>
  </div>

  <h2>Pipeline definition</h2>
  <p>The top-level fields of a pipeline definition:</p>

  <table class="docs-table">
    <thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Pipeline name, used in logs and UI</td></tr>
      <tr><td><code>description</code></td><td>string</td><td>No</td><td>Human-readable description</td></tr>
      <tr><td><code>version</code></td><td>integer</td><td>Yes</td><td>Schema version (currently 1)</td></tr>
      <tr><td><code>variables</code></td><td>object</td><td>No</td><td set:html="'Global variables accessible via <code>{{vars.xxx}}</code>'" /></tr>
      <tr><td><code>input</code></td><td>object</td><td>No</td><td>Input schema for trigger-time data</td></tr>
      <tr><td><code>steps</code></td><td>array</td><td>Yes</td><td>Ordered list of pipeline steps</td></tr>
    </tbody>
  </table>

  <h2>Step types</h2>
  <p>Each step in a pipeline has a type that determines how it executes. The default type is <code>llm</code>.</p>

  <table class="docs-table">
    <thead><tr><th>Type</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><code>llm</code></td><td>Default. Sends prompt to a model and returns text output.</td></tr>
      <tr><td><code>transform</code></td><td>No model call. Manipulate data with JSON extract, regex, or templates.</td></tr>
      <tr><td><code>condition</code></td><td>Branch based on previous step output.</td></tr>
      <tr><td><code>parallel</code></td><td>Run multiple steps concurrently and merge results.</td></tr>
      <tr><td><code>webhook</code></td><td>Call an external HTTP endpoint.</td></tr>
      <tr><td><code>human_review</code></td><td>Pause pipeline and wait for human approval before continuing.</td></tr>
      <tr><td><code>code</code></td><td>Run sandboxed Python or JavaScript code on the output.</td></tr>
    </tbody>
  </table>

  <h2 id="variables">Variable interpolation</h2>
  <p>Use Handlebars-like syntax to reference data in prompts and configurations. Variables are resolved at execution time.</p>

  <table class="docs-table">
    <thead><tr><th>Syntax</th><th>Description</th></tr></thead>
    <tbody>
      {varsTable.map((v) => (
        <tr>
          <td><code set:html={v.syntax} /></td>
          <td>{v.desc}</td>
        </tr>
      ))}
    </tbody>
  </table>

  <h2>Output delivery</h2>
  <p>Configure where the final pipeline output gets delivered. Multiple delivery targets can be specified.</p>

  <div class="docs-card-grid">
    <div class="docs-card">
      <h3>Webhook</h3>
      <p>POST to any URL with the pipeline output as JSON body.</p>
    </div>
    <div class="docs-card">
      <h3>Email</h3>
      <p>Send output via email with configurable subject and recipients.</p>
    </div>
    <div class="docs-card">
      <h3>API Response</h3>
      <p>Return output directly in the API response body.</p>
    </div>
  </div>
</DocsLayout>
